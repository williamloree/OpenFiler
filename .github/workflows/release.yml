name: Auto Release

on:
  push:
    branches: [main]

jobs:
  release:
    # Skip release commits to avoid infinite loop
    if: "!contains(github.event.head_commit.message, '[skip ci]')"
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout with full history
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Determine version
        id: version
        run: |
          LAST_TAG=$(git tag -l 'v*' --sort=-v:refname | head -n1)

          if [ -z "$LAST_TAG" ]; then
            NEW_VERSION="1.0.0"
            COMMIT_RANGE="HEAD"
          else
            MAJOR=$(echo "$LAST_TAG" | sed 's/v//' | cut -d. -f1)
            MINOR=$(echo "$LAST_TAG" | sed 's/v//' | cut -d. -f2)
            PATCH=$(echo "$LAST_TAG" | sed 's/v//' | cut -d. -f3)
            PATCH=$((PATCH + 1))
            NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
            COMMIT_RANGE="${LAST_TAG}..HEAD"
          fi

          echo "version=${NEW_VERSION}" >> "$GITHUB_OUTPUT"
          echo "tag=v${NEW_VERSION}" >> "$GITHUB_OUTPUT"
          echo "range=${COMMIT_RANGE}" >> "$GITHUB_OUTPUT"
          echo "New version: ${NEW_VERSION}"

      - name: Collect changes
        id: changes
        run: |
          RANGE="${{ steps.version.outputs.range }}"

          if [ "$RANGE" = "HEAD" ]; then
            COMMITS=$(git log --pretty=format:"%s" --no-merges)
          else
            COMMITS=$(git log "${RANGE}" --pretty=format:"%s" --no-merges)
          fi

          # Filter out release bot commits
          COMMITS=$(echo "$COMMITS" | grep -v "^\[skip ci\]" | grep -v "^chore(release):" || true)

          if [ -z "$COMMITS" ]; then
            echo "No changes found"
            echo "has_changes=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "has_changes=true" >> "$GITHUB_OUTPUT"

          # Save commits to file for later use
          echo "$COMMITS" > /tmp/commits.txt

          # Build release notes markdown
          {
            echo "## What's Changed in v${{ steps.version.outputs.version }}"
            echo ""
            echo "$COMMITS" | while IFS= read -r line; do
              [ -n "$line" ] && echo "- ${line}"
            done
          } > /tmp/release_notes.md

          cat /tmp/release_notes.md

      - name: Update release.json
        if: steps.changes.outputs.has_changes == 'true'
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          TAG="${{ steps.version.outputs.tag }}"
          DATE=$(date -u +"%Y-%m-%d")

          # Read commits and build JSON array of changes
          CHANGES_JSON="[]"
          while IFS= read -r line; do
            if [ -n "$line" ]; then
              ESCAPED=$(echo "$line" | sed 's/\\/\\\\/g; s/"/\\"/g')
              CHANGES_JSON=$(echo "$CHANGES_JSON" | jq --arg c "$ESCAPED" '. + [$c]')
            fi
          done < /tmp/commits.txt

          # Build the new release entry
          NEW_ENTRY=$(jq -n \
            --arg version "$VERSION" \
            --arg date "$DATE" \
            --arg tag "$TAG" \
            --argjson changes "$CHANGES_JSON" \
            '{ version: $version, date: $date, tag: $tag, changes: $changes }')

          # Read existing release.json or start with empty array
          if [ -f release.json ]; then
            EXISTING=$(cat release.json)
          else
            EXISTING="[]"
          fi

          # Append new entry
          echo "$EXISTING" | jq --argjson entry "$NEW_ENTRY" '. + [$entry]' > release.json

          cat release.json

      - name: Commit and push release.json
        if: steps.changes.outputs.has_changes == 'true'
        run: |
          git add release.json
          git commit -m "chore(release): v${{ steps.version.outputs.version }} [skip ci]"
          git push

      - name: Create tag
        if: steps.changes.outputs.has_changes == 'true'
        run: |
          git tag "${{ steps.version.outputs.tag }}"
          git push origin "${{ steps.version.outputs.tag }}"

      - name: Create GitHub Release
        if: steps.changes.outputs.has_changes == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release create "${{ steps.version.outputs.tag }}" \
            --title "Release ${{ steps.version.outputs.tag }}" \
            --notes-file /tmp/release_notes.md
